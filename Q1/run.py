# -*- coding: utf-8 -*-import cv2import numpy as npimport osfrom datetime import datetime from edge import *from deskew import *from corner import *from keyvalue import *def nothing(x):    pass    def setcamera():    Brightness = cv2.getTrackbarPos('Brightness','video')    Contrast = cv2.getTrackbarPos('Contrast','video')    Saturation = cv2.getTrackbarPos('Saturation','video')    Hue = cv2.getTrackbarPos('Hue','video')    Gain = cv2.getTrackbarPos('Gain','video')    camera.set(10,Brightness)    camera.set(11,Contrast)    camera.set(12,Saturation)    camera.set(13,Hue)    camera.set(14,Gain)def getcornerimage(imgrotate):    t1 = imgrotate[cornerup:cornerdown,cornerleft:cornerright]    t2 = imgrotate[cornerleft:cornerright,acornerdown:acornerup]    t3 = imgrotate[acornerright:acornerleft,cornerup:cornerdown]    t4 = imgrotate[acornerdown:acornerup,acornerright:acornerleft]    #t2 = t2.T[::-1,:]    #t3 = t3.T[:,::-1]    #t4 = t4[::-1,::-1]    t2 = rotateImage2(t2,90)#[30:130,180:220]    t3 = rotateImage2(t3,270)#[30:130,180:220]    t4 = rotateImage(t4,180)#[50:150,20:60]    t2 = t2[0.5 * t2.shape[0] - 0.5 * (cornerdown - cornerup):0.5 * t2.shape[0] + 0.5 * (cornerdown - cornerup),0.5 * t2.shape[1] - 0.5 * (cornerright - cornerleft):0.5 * t2.shape[1] + 0.5 * (cornerright - cornerleft)]    t3 = t3[0.5 * t3.shape[0] - 0.5 * (cornerdown - cornerup):0.5 * t3.shape[0] + 0.5 * (cornerdown - cornerup),0.5 * t3.shape[1] - 0.5 * (cornerright - cornerleft):0.5 * t3.shape[1] + 0.5 * (cornerright - cornerleft)]    t4 = t4[0.5 * t4.shape[0] - 0.5 * (cornerdown - cornerup):0.5 * t4.shape[0] + 0.5 * (cornerdown - cornerup),0.5 * t4.shape[1] - 0.5 * (cornerright - cornerleft):0.5 * t4.shape[1] + 0.5 * (cornerright - cornerleft)]    return t1,t2,t3,t4    def issymbol(x,y,w,h,area):    if (x+w) > 55:        return False    if y < 50:        return False    if(area<450) :                   #it is small symbol        #if (17<h)and(h<28):        if (15<h)and(h<31):            if (15<w)and(w<30):                return True    return False    def isnumber(x,y,w,h,area):    if(y+h) > 80:        return False    if(350<area) :                   #it is small symbol        #if (20<h)and(h<60):            #if (15<w)and(w<30):        if  40 < h:            return True    return False    def printresult(result):    print result    showsymbol = 'nan'    shownumber = 'nan'        if len(result) == 1:        showsymbol = result[0][0][0][0]        shownumber = result[0][1][0][0]    elif len(result) == 2:        result.sort(key=lambda s:s[0][0][1])        showsymbol = result[0][0][0][0]        result.sort(key=lambda s:s[1][0][1])        shownumber = result[0][1][0][0]            if shownumber == '0':        shownumber = '10'            print showsymbol," : ",shownumber    #######   training part    ############### samples = np.loadtxt('generalsamples.data',np.float32)responses = np.loadtxt('generalresponses.data',np.float32)responses = responses.reshape((responses.size,1))model = cv2.KNearest()model.train(samples,responses)##########################################isshowall = Truecamera_port = 0camera = cv2.VideoCapture(camera_port)#######   camera default setting    ######camera.set(10,20)  #Brightnesscamera.set(11,20)  #Contrastcamera.set(12,50)  #Saturationcamera.set(13,18)  #Huecamera.set(14,14)  #Gainfor cap in range(10,15):    print camera.get(cap)##########################################if not camera.isOpened():    print "Cannot open camera!"else:    take_picture = False;    t0, filenum = 0, 1        #cv2.namedWindow('video')    #cv2.createTrackbar('Brightness','video',0,100,nothing)    #cv2.createTrackbar('contrast','video',0,100,nothing)    #cv2.createTrackbar('Saturation','video',0,100,nothing)    #cv2.createTrackbar('Hue','video',0,100,nothing)    #cv2.createTrackbar('Gain','video',0,100,nothing)    while True:        #setcamera()        val, im = camera.read()        cv2.imshow("video", im)                key = cv2.waitKey(30)        if key == ord(' '):            t0 = cv2.getTickCount()            take_picture = True            os.system('cls')        elif key == 27:            break        if take_picture and ((cv2.getTickCount()-t0) / cv2.getTickFrequency()) > 1:            starttime = datetime.now()             result = []            #threshold start                        #b = cv2.adaptiveThreshold(im[:,:,0],255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,1,11,4)            #g = cv2.adaptiveThreshold(im[:,:,1],255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,1,11,4)            #r = cv2.adaptiveThreshold(im[:,:,2],255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,1,11,4)            #all = b & g & r            #cv2.imshow('b',b)            #cv2.imshow('g',g)            #cv2.imshow('r',r)            #cv2.imshow('all',all)                        img = cv2.cvtColor(im,cv2.COLOR_RGB2GRAY)            img = cv2.medianBlur(img,5)            img = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,1,11,3)                        img = cutpoker(img)            angel = getdeskewangle(img)            imgrotate = rotateImage(img,angel)            imgrotate = cutpoker(imgrotate)                        targets = [t1,t2,t3,t4] = getcornerimage(imgrotate)                        if isshowall:                cv2.imshow('cut',img)                cv2.imshow('rotate',imgrotate)                cv2.imshow('target1',t1)                cv2.imshow('target2',t2)                cv2.imshow('target3',t3)                cv2.imshow('target4',t4)                #print t1.sum(),t2.sum(),t3.sum(),t4.sum()                        for target in targets:                contours,hierarchy = cv2.findContours(target,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)                                number = []                symbol = []                flagN = 0                flagS = 0                                for cnt in contours:                    area = cv2.contourArea(cnt)                    if (100 < area) and (area<1200):                        [x,y,w,h] = cv2.boundingRect(cnt)                                roi = target[y:y+h,x:x+w]                        roismall = cv2.resize(roi,(10,10))                        roismall = roismall.reshape((1,100))                        roismall = np.float32(roismall)                        retval, results, neigh_resp, dists = model.find_nearest(roismall, k = 3)                        print retval, results, neigh_resp, dists                        print  [x,y,w,h],cv2.contourArea(cnt)                        if retval < 255:                            if isnumber(x,y,w,h,area):                                if retval in keysOfPokerNumber:                                    number.append((chr(int(retval)),int(dists[0][neigh_resp[0].tolist().index(retval)])))                                    flagN = 1                                else:                                    for index,neighbor in enumerate(neigh_resp[0]):                                        if neighbor in keysOfPokerNumber:                                            number.append((chr(int(neighbor)),int(dists[0][neigh_resp[0].tolist().index(retval)])))                                            flagN = 1                                            break                                                                elif issymbol(x,y,w,h,area):                                if retval in keysOfPokerSymbol:                                    symbol.append((chr(int(retval)),int(dists[0][neigh_resp[0].tolist().index(retval)])))                                    flagS = 1                                else:                                    for index,neighbor in enumerate(neigh_resp[0]):                                        if neighbor in keysOfPokerSymbol:                                            symbol.append((chr(int(neighbor)),int(dists[0][neigh_resp[0].tolist().index(retval)])))                                            flagS = 1                                            break                            #if retval in keysOfPokerNumber:                                #if isnumber(x,y,w,h,area):                                    #number.append((chr(int((results[0][0]))),int((dists[0][0]))))                                    #number.append((chr(int(retval)),int((dists[0][0]))))                                    #flagN = 1                                    #print  [x,y,w,h],cv2.contourArea(cnt)                                    #print chr(int((results[0][0])))," : ",int((dists[0][0]))                                    #print                                #else:                                    #print "number",chr(int((results[0][0])))," : ",int((dists[0][0]))                                    #print x,y,w,h,area                            #elif retval in keysOfPokerSymbol:                                #if issymbol(x,y,w,h,area):                                    #symbol.append((chr(int((results[0][0]))),int((dists[0][0]))))                                    #symbol.append((chr(int(retval)),int((dists[0][0]))))                                    #flagS = 1                                    #print  [x,y,w,h],cv2.contourArea(cnt)                                    #print chr(int((results[0][0])))," : ",int((dists[0][0]))                                    #print                                #else:                                    #print "symbol",chr(int((results[0][0])))," : ",int((dists[0][0]))                                    #print x,y,w,h,area                                                        #print retval, results, neigh_resp, dists                                 if (flagN == 1) and (flagS == 1):                    print symbol , " : " , number                    result.append((symbol,number))                                print "**************************************"                            endtime = datetime.now()                        printresult(result)            print 'process time : ' + str(endtime - starttime)                        take_picture = False                camera.release()