import cv2import Imageimport numpy as npimport osfrom datetime import datetime from edge import *from deskew import *#some key valuej = [74,106] #key j Jq = [81,113] #key q Qk = [75,107] #key k Knumber0to9 = [i for i in range(48,58)] #key 0 to 9spade = [85,115] #key s Sheart = [72,104] #key h Hdiamond = [68,100] #key d Dclub = [67,99] #key c CkeysOfPokerNumber = number0to9 + j + q + kkeysOfPokerSymbol = spade + heart + diamond + clubkeys = keysOfPokerNumber + keysOfPokerSymbol#######   training part    ############### samples = np.loadtxt('generalsamples.data',np.float32)responses = np.loadtxt('generalresponses.data',np.float32)responses = responses.reshape((responses.size,1))model = cv2.KNearest()model.train(samples,responses)##########################################camera_port = 0camera = cv2.VideoCapture(camera_port)if not camera.isOpened():    print "Cannot open camera!"else:    take_picture = False;    t0, filenum = 0, 1    while True:        val, im = camera.read()        cv2.imshow("video", im)                key = cv2.waitKey(30)        if key == ord(' '):            t0 = cv2.getTickCount()            take_picture = True        elif key == 27:            break        if take_picture and ((cv2.getTickCount()-t0) / cv2.getTickFrequency()) > 1:            starttime = datetime.now()             #threshold start            img = cv2.cvtColor(im,cv2.COLOR_RGB2GRAY)            img = cv2.medianBlur(img,5)            thresh = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,1,11,3)            img = cutpoker(thresh)            angel = getdeskewangle(img)            imgrotate = rotateImage(img,angel)            imgrotate = cutpoker(imgrotate)                        cv2.imshow('cut',img)            cv2.imshow('rotate',imgrotate)            t1 = imgrotate[20:120,20:60]            t2 = imgrotate[20:60,-120:-20]            t3 = imgrotate[-60:-20,20:120]            t4 = imgrotate[-120:-20,-60:-20]            #t2 = t2.T[::-1,:]            #t3 = t3.T[:,::-1]            #t4 = t4[::-1,::-1]            t2 = rotateImage2(t2,90)[30:130,180:220]            t3 = rotateImage2(t3,270)[30:130,180:220]            t4 = rotateImage(t4,180)[50:150,20:60]            cv2.imshow('target1',t1)            cv2.imshow('target2',t2)            cv2.imshow('target3',t3)            cv2.imshow('target4',t4)            print t1.sum(),t2.sum(),t3.sum(),t4.sum()            targets = [t1,t2,t3,t4]                        for target in targets:                contours,hierarchy = cv2.findContours(target,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)                                number = []                symbol = 0                flagN = 0                flagS = 0                                for cnt in contours:                    if (100 < cv2.contourArea(cnt)) and (cv2.contourArea(cnt)<1000):                        #os.system('cls')                                                [x,y,w,h] = cv2.boundingRect(cnt)                                                roi = target[y:y+h,x:x+w]                        roismall = cv2.resize(roi,(10,10))                        roismall = roismall.reshape((1,100))                        roismall = np.float32(roismall)                        retval, results, neigh_resp, dists = model.find_nearest(roismall, k = 1)                        if retval < 255:                            if retval in keysOfPokerNumber:                                number.append(chr(int((results[0][0]))))                                flagN = 1                            elif retval in keysOfPokerSymbol:                                symbol = chr(int((results[0][0])))                                flagS = 1                            #print chr(int((results[0][0])))," : ",int((dists[0][0]))                            #print retval, results, neigh_resp, dists                         #string = str(int((results[0][0])))                        #cv2.putText(out,string,(x,y+h),0,1,(0,255,0))                if (flagN == 1) and (flagS == 1):                #print flagN,flagS                    print symbol , " : " , number                            endtime = datetime.now()            print 'process time : ' + str(endtime - starttime)                        take_picture = False                camera.release()